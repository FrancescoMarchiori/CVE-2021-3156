# 🔍 Fuzzing Techniques

Before going deep into the details of our exploit and the steps than need to be performed, we want to discuss about why the vulnerability has been hidden for almost ten years and neither with fuzzing techniques it has been possible to discover it before. The code in this directory consists of a merge of the different episodes of the [LiveOverflow](https://github.com/LiveOverflow/pwnedit) series on the CVE-2021-3156 vulnerability. We will use AFL/AFL++.

## 🛠️ Installation and Usage

First, unpack the `sudo` source code by running:

```bash
tar -xvf sudo-1.8.31p2.tar.gz
```

To run the docker container it's possible to use the `Makefile` and thus run:

```bash
sudo make
```

At this point, we can get a root shell by running `sudo make root` or a regular user shell by running. `sudo make attach`. At this point, it should be possible to check if we have the vulnerable version of sudo by trying it on a shell and checking the result:

```bash
sudoedit -s 'AAAAAAAAAAAA\'
# malloc(): invalid size (unsorted)
# Aborted
```

## 🔠 Problem #1 - Fuzzing arguments

The first problem that we encounter when fuzzing sudo is the fact that most fuzzers out of the box only are designed to target stdin or input files, while the sudo vulnerability is affected by its arguments. This require particular attention: in the case of AFL an experimental feature must be used, which involved the addition of a particular header in the sudo source folder and slightly modidying the main function by including the header and adding a macro at the beginning of the code. 

```diff
--- ./sudo-1.8.31p2/src/sudo.c
+++ ./sudo-1.8.31p2/src/sudo.c
@@ -68,6 +68,7 @@
 #include "sudo.h"
 #include "sudo_plugin.h"
 #include "sudo_plugin_int.h"
+#include "argv-fuzz-inl.h"
 
 /*
  * Local variables
@@ -134,6 +135,7 @@
 int
 main(int argc, char *argv[], char *envp[])
 {
+	AFL_INIT_ARGV();
     int nargc, ok, status = 0;
     char **nargv, **env_add;
     char **user_info, **command_info, **argv_out, **user_env_out;
```

## 💥 Problem #2 - Crashes before receiving input

After making these adjustments however, fuzzing sudo terminates with a crash in the code that we injected before receiving any input from the fuzzer. In order to solve this, we must switch the `afl-gcc` instrumentation with an LLVM-based one such as [Clang](https://clang.llvm.org/), or more simply by using the advanced [AFL++](https://github.com/AFLplusplus/AFLplusplus) fuzzer.

## ❓ Problem #3 - Can't find crashes

Even though the fuzzer now works, we are not able to report any crashes. This happens because we are now fuzzing sudo instead of sudoedit, which is a symlink of sudo. This means that we must include the filename, i.e. `argv[0]`, in the fuzzing targets. However, sudo uses the `__progname` variable to retrieve the name of the program, thus further modifications in the code are needed in order to make it take `argv[0]` as the name.

First we have to adjust the `rc` start value in [`argv-fuzz-inl.h`](argv-fuzz-inl.h)

```c
int   rc  = 0; /* include argv[0] */
```

Then we want to remove `getprogname()` and `__progname`, and always use the fallback `argv[0]`.

```diff
--- ./sudo-1.8.31p2/lib/util/progname.c
+++ ./sudo-1.8.31p2/lib/util/progname.c
@@ -36,43 +36,12 @@
 #include "sudo_compat.h"
 #include "sudo_util.h"

-#ifdef HAVE_GETPROGNAME
-
-void
-initprogname(const char *name)
-{
-# ifdef HAVE_SETPROGNAME
-    const char *progname;
-
-    /* Fall back on "name" if getprogname() returns an empty string. */
-    if ((progname = getprogname()) != NULL && *progname != '\0')
-	name = progname;
-
-    /* Check for libtool prefix and strip it if present. */
-    if (name[0] == 'l' && name[1] == 't' && name[2] == '-' && name[3] != '\0')
-	name += 3;
-
-    /* Update internal progname if needed. */
-    if (name != progname)
-	setprogname(name);
-# endif
-    return;
-}
-
-#else /* !HAVE_GETPROGNAME */
-
 static const char *progname = "";

 void
 initprogname(const char *name)
 {
-# ifdef HAVE___PROGNAME
-    extern const char *__progname;

-    if (__progname != NULL && *__progname != '\0')
-	progname = __progname;
-    else
-# endif
     if ((progname = strrchr(name, '/')) != NULL) {
 	progname++;
     } else {
@@ -90,4 +59,3 @@
 {
     return progname;
 }
-#endif /* !HAVE_GETPROGNAME */
```

## 🏷️ Problem #4 - Modifying user ID

The last modification that we need to do in the sudo code regards the user id. Indeed, we are targeting a binary program that is inteded to run as root via setuid, but is executed by a normal user, therefore we should fuzz the program as user while running it as root; however this is a problem since fuzzers need root privileges in order to behave correctly. The solution to this is running everything as root, but forcing sudo to think it has been executed by an unprivileged user: this could be done by looking in the code where sudo invokes `getuid()` and just hardcode the value to 1000, which is the user id of a regular user.

```diff
--- ./sudo-1.8.31p2/src/sudo.c
+++ ./sudo-1.8.31p2/src/sudo.c
@@ -522,9 +524,9 @@
     }
     ud->sid = getsid(0);

-    ud->uid = getuid();
+    ud->uid = 1000; //getuid();
     ud->euid = geteuid();
-    ud->gid = getgid();
+    ud->gid = 1000; //getgid();
     ud->egid = getegid();
```